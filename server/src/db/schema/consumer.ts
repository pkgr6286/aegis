import {
  pgTableCreator,
  uuid,
  varchar,
  timestamp,
  jsonb,
  pgEnum,
  index,
  uniqueIndex,
  text,
} from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';
import { tenants } from './public';
import { drugPrograms, screenerVersions } from './programs';

/**
 * Use the app table creator.
 * RLS MUST be enabled on all tables created here.
 */
const appTable = pgTableCreator((name) => `${name}`);

// ------------------------------------------------------------------
// ENUMS (Consumer-Scoped)
// ------------------------------------------------------------------

export const sessionStatusEnum = pgEnum('session_status', ['started', 'completed']);
export const sessionOutcomeEnum = pgEnum('session_outcome', ['ok_to_use', 'ask_a_doctor', 'do_not_use']);
export const sessionPathEnum = pgEnum('session_path', ['manual', 'ehr_assisted', 'ehr_mandatory']);
export const consentStatusEnum = pgEnum('consent_status', ['granted', 'revoked', 'failed']);
export const codeStatusEnum = pgEnum('code_status', ['unused', 'used', 'expired']);
export const codeTypeEnum = pgEnum('code_type', ['pos_barcode', 'ecommerce_jwt']);

// ------------------------------------------------------------------
// TABLES (Consumer-Scoped)
// ------------------------------------------------------------------

/**
 * A record of a single consumer's attempt to complete a screener.
 * This is the primary source of Real-World Evidence (RWE).
 */
export const screeningSessions = appTable('screening_sessions', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  drugProgramId: uuid('drug_program_id').notNull().references(() => drugPrograms.id, { onDelete: 'cascade' }),
  
  /**
   * "Freezes" the exact screener version the consumer used.
   * This is a critical audit and compliance requirement.
   */
  screenerVersionId: uuid('screener_version_id').notNull().references(() => screenerVersions.id, { onDelete: 'restrict' }),

  status: sessionStatusEnum('status').notNull().default('started'),
  outcome: sessionOutcomeEnum('outcome'), // Nullable until 'completed'
  path: sessionPathEnum('path').notNull().default('manual'),

  /**
   * Stores the consumer's answers, e.g., { "q1": "yes", "q5_ldl": 140 }
   */
  answersJson: jsonb('answers_json').notNull().default('{}'),

  createdAt: timestamp('created_at').notNull().defaultNow(),
  completedAt: timestamp('completed_at'),
}, (table) => ({
  // Index for RWE analytics dashboard (e.g., "show me all outcomes for this program")
  programOutcomeIdx: index('ss_program_outcome_idx').on(table.tenantId, table.drugProgramId, table.outcome),
  // Index for RWE analytics over time
  programTimeIdx: index('ss_program_time_idx').on(table.tenantId, table.drugProgramId, table.createdAt),
}));

/**
 * The single-use verification code generated for a successful session.
 * This is the "key" that unlocks the purchase at POS or e-commerce.
 */
export const verificationCodes = appTable('verification_codes', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  
  /**
   * A verification code is ALWAYS tied to a screening session.
   * Enforced with a unique constraint for a one-to-one relationship.
   */
  screeningSessionId: uuid('screening_session_id').notNull().references(() => screeningSessions.id, { onDelete: 'cascade' }),

  /**
   * The short, human-readable/scannable code.
   * Generated by the application (e.g., 8-char nanoid).
   */
  code: varchar('code', { length: 32 }).notNull(),
  
  type: codeTypeEnum('type').notNull().default('pos_barcode'),
  status: codeStatusEnum('status').notNull().default('unused'),
  
  expiresAt: timestamp('expires_at').notNull(),
  usedAt: timestamp('used_at'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
}, (table) => ({
  // CRITICAL: A unique index on the code for fast lookups by the Verification API.
  codeIdx: uniqueIndex('vc_code_idx').on(table.code),
  
  // Unique constraint on screening_session_id for one-to-one relationship
  sessionIdx: uniqueIndex('vc_session_idx').on(table.screeningSessionId),
  
  // Index for a background job to clean up expired codes
  statusExpiresIdx: index('vc_status_expires_idx').on(table.tenantId, table.status, table.expiresAt),
}));

/**
 * An immutable, auditable log of a consumer granting EHR consent.
 * This is a legal and compliance requirement.
 */
export const ehrConsents = appTable('ehr_consents', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  
  // Links to the session where consent was given
  screeningSessionId: uuid('screening_session_id').notNull().references(() => screeningSessions.id, { onDelete: 'cascade' }),
  
  status: consentStatusEnum('status').notNull(),
  providerName: varchar('provider_name', { length: 255 }), // e.g., "MyChart - Example Hospital"
  
  // Stores the list of scopes/permissions granted, e.g., ['LabResults', 'Medications']
  scopesGranted: text('scopes_granted').array(),
  
  createdAt: timestamp('created_at').notNull().defaultNow(),
}, (table) => ({
  // Index for auditing consents for a specific session
  sessionIdx: index('ec_session_idx').on(table.tenantId, table.screeningSessionId),
}));

// ------------------------------------------------------------------
// RELATIONS (Consumer-Scoped)
// ------------------------------------------------------------------

export const screeningSessionsRelations = relations(screeningSessions, ({ one }) => ({
  tenant: one(tenants, {
    fields: [screeningSessions.tenantId],
    references: [tenants.id],
  }),
  drugProgram: one(drugPrograms, {
    fields: [screeningSessions.drugProgramId],
    references: [drugPrograms.id],
  }),
  screenerVersion: one(screenerVersions, {
    fields: [screeningSessions.screenerVersionId],
    references: [screenerVersions.id],
  }),
  // One-to-one relation
  verificationCode: one(verificationCodes, {
    fields: [screeningSessions.id],
    references: [verificationCodes.screeningSessionId],
  }),
  // One-to-one relation
  ehrConsent: one(ehrConsents, {
    fields: [screeningSessions.id],
    references: [ehrConsents.screeningSessionId],
  }),
}));

export const verificationCodesRelations = relations(verificationCodes, ({ one }) => ({
  tenant: one(tenants, {
    fields: [verificationCodes.tenantId],
    references: [tenants.id],
  }),
  screeningSession: one(screeningSessions, {
    fields: [verificationCodes.screeningSessionId],
    references: [screeningSessions.id],
  }),
}));

export const ehrConsentsRelations = relations(ehrConsents, ({ one }) => ({
  tenant: one(tenants, {
    fields: [ehrConsents.tenantId],
    references: [tenants.id],
  }),
  screeningSession: one(screeningSessions, {
    fields: [ehrConsents.screeningSessionId],
    references: [screeningSessions.id],
  }),
}));
