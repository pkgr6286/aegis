import {
  pgTableCreator,
  uuid,
  varchar,
  timestamp,
  jsonb,
  pgEnum,
  index,
  integer,
  foreignKey,
} from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';
import { tenants, users } from './public';
import { auditSchema } from './core';

/**
 * Use the app table creator for all tenant-scoped business logic tables.
 * RLS (Row-Level Security) MUST be enabled on all tables created here.
 */
const appTable = pgTableCreator((name) => `${name}`);

// ------------------------------------------------------------------
// ENUMS (Program-Scoped)
// ------------------------------------------------------------------

export const programStatusEnum = pgEnum('program_status', ['draft', 'active', 'archived']);

// ------------------------------------------------------------------
// TABLES (Program-Scoped)
// ------------------------------------------------------------------

/**
 * Stores tenant-specific brand configurations (logos, colors).
 * A single brand can be applied to multiple drug programs.
 */
export const brandConfigs = appTable('brand_configs', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  name: varchar('name', { length: 255 }).notNull(), // e.g., "Kenvue Primary Brand"
  
  /**
   * Stores branding assets like { logoUrl: '...', primaryColor: '#...', etc }
   */
  config: jsonb('config').notNull().default('{}'),

  ...auditSchema,
}, (table) => ({
  // Index for RLS-scoped lookups by name
  tenantNameIdx: index('bc_tenant_name_idx').on(table.tenantId, table.name),
}));

/**
 * Reference for screener_versions - forward declared for circular dependency
 */
declare const screenerVersions: ReturnType<typeof appTable>;

/**
 * The core Drug Program object (e.g., "Rosuvastatin 5mg").
 * This is the parent entity for screeners and consumer sessions.
 */
export const drugPrograms = appTable('drug_programs', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),

  // Foreign key to the brand config
  brandConfigId: uuid('brand_config_id').references(() => brandConfigs.id, { onDelete: 'set null' }),

  name: varchar('name', { length: 255 }).notNull(), // Internal name
  brandName: varchar('brand_name', { length: 255 }), // Consumer-facing name (e.g., "Crestor-OTC")
  status: programStatusEnum('status').notNull().default('draft'),

  /**
   * A 'soft' foreign key to the single, currently active screener version.
   * This is set by the application logic when an admin "publishes" a version.
   */
  activeScreenerVersionId: uuid('active_screener_version_id'),
  
  ...auditSchema,
}, (table) => ({
  // Composite index for the main admin dashboard (RLS-scoped)
  tenantStatusIdx: index('dp_tenant_status_idx').on(table.tenantId, table.status),
}));

/**
 * Stores a versioned, immutable snapshot of a screener's configuration.
 * A new record is created every time an admin saves changes.
 */
export const screenerVersions = appTable('screener_versions', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  drugProgramId: uuid('drug_program_id').notNull().references(() => drugPrograms.id, { onDelete: 'cascade' }),

  /**
   * The version number (1, 2, 3...) scoped to the drug program.
   * This is managed by the application logic (SELECT MAX(version) + 1).
   */
  version: integer('version').notNull(),
  
  /**
   * The complete screener definition as JSON, generated by the frontend builder.
   * Includes all questions, logic, branching, and EHR mappings.
   */
  screenerJson: jsonb('screener_json').notNull().default('{}'),
  
  // Admin-facing notes for this version (e.g., "v2.1 - Added EHR check")
  notes: varchar('notes', { length: 1024 }),
  
  ...auditSchema,
}, (table) => ({
  // Critical index for finding all versions for a program
  programVersionIdx: index('sv_program_version_idx').on(table.tenantId, table.drugProgramId, table.version),
}));

// ------------------------------------------------------------------
// RELATIONS (Program-Scoped)
// ------------------------------------------------------------------

export const brandConfigsRelations = relations(brandConfigs, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [brandConfigs.tenantId],
    references: [tenants.id],
  }),
  drugPrograms: many(drugPrograms),
}));

export const drugProgramsRelations = relations(drugPrograms, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [drugPrograms.tenantId],
    references: [tenants.id],
  }),
  brandConfig: one(brandConfigs, {
    fields: [drugPrograms.brandConfigId],
    references: [brandConfigs.id],
  }),
  activeScreenerVersion: one(screenerVersions, {
    fields: [drugPrograms.activeScreenerVersionId],
    references: [screenerVersions.id],
    relationName: 'active_version',
  }),
  allScreenerVersions: many(screenerVersions, {
    relationName: 'all_versions',
  }),
  screeningSessions: many('screeningSessions'), // Forward reference to consumer.ts
}));

export const screenerVersionsRelations = relations(screenerVersions, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [screenerVersions.tenantId],
    references: [tenants.id],
  }),
  drugProgram: one(drugPrograms, {
    fields: [screenerVersions.drugProgramId],
    references: [drugPrograms.id],
    relationName: 'all_versions',
  }),
  screeningSessions: many('screeningSessions'), // Forward reference to consumer.ts
  
  // Relations for the createdBy/updatedBy fields from auditSchema
  creator: one(users, {
    fields: [screenerVersions.createdBy],
    references: [users.id],
    relationName: 'creator',
  }),
  updater: one(users, {
    fields: [screenerVersions.updatedBy],
    references: [users.id],
    relationName: 'updater',
  }),
}));
