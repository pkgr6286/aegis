import {
  pgTableCreator,
  uuid,
  varchar,
  timestamp,
  jsonb,
  pgEnum,
  index,
  integer,
  foreignKey,
} from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';
import { tenants, users } from './public';
import { auditSchema } from './core';

// Forward declaration of screeningSessions for circular dependency
// Will be imported after consumer.ts is fully defined
let screeningSessions: any;

/**
 * Use the app table creator for all tenant-scoped business logic tables.
 * RLS (Row-Level Security) MUST be enabled on all tables created here.
 */
const appTable = pgTableCreator((name) => `${name}`);

// ------------------------------------------------------------------
// ENUMS (Program-Scoped)
// ------------------------------------------------------------------

export const programStatusEnum = pgEnum('program_status', ['draft', 'active', 'archived']);

export const regulatoryDocCategoryEnum = pgEnum('regulatory_doc_category', [
  'samd_core',
  'verification_validation',
  'risk_cybersecurity',
  'acnu_specific',
  'regulatory_submissions',
  'compliance_qms',
  'post_market_surveillance'
]);

export const accessLevelEnum = pgEnum('access_level', ['admin', 'internal', 'external']);

// ------------------------------------------------------------------
// TABLES (Program-Scoped)
// ------------------------------------------------------------------

/**
 * Stores tenant-specific brand configurations (logos, colors).
 * A single brand can be applied to multiple drug programs.
 */
export const brandConfigs = appTable('brand_configs', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  name: varchar('name', { length: 255 }).notNull(), // e.g., "Kenvue Primary Brand"
  
  /**
   * Stores branding assets like { logoUrl: '...', primaryColor: '#...', etc }
   */
  config: jsonb('config').notNull().default('{}'),

  ...auditSchema,
}, (table) => ({
  // Index for RLS-scoped lookups by name
  tenantNameIdx: index('bc_tenant_name_idx').on(table.tenantId, table.name),
}));

/**
 * The core Drug Program object (e.g., "Rosuvastatin 5mg").
 * This is the parent entity for screeners and consumer sessions.
 */
export const drugPrograms = appTable('drug_programs', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),

  // Foreign key to the brand config
  brandConfigId: uuid('brand_config_id').references(() => brandConfigs.id, { onDelete: 'set null' }),

  name: varchar('name', { length: 255 }).notNull(), // Internal name
  brandName: varchar('brand_name', { length: 255 }), // Consumer-facing name (e.g., "Crestor-OTC")
  
  /**
   * Public-facing slug for QR code/URL access (e.g., "crestor-otc-5mg")
   * Must be unique across ALL tenants for public lookups
   * Nullable to allow safe migration - existing programs need slugs added manually
   */
  slug: varchar('slug', { length: 255 }).unique(),
  
  status: programStatusEnum('status').notNull().default('draft'),

  /**
   * A 'soft' foreign key to the single, currently active screener version.
   * This is set by the application logic when an admin "publishes" a version.
   */
  activeScreenerVersionId: uuid('active_screener_version_id'),
  
  ...auditSchema,
}, (table) => ({
  // Composite index for the main admin dashboard (RLS-scoped)
  tenantStatusIdx: index('dp_tenant_status_idx').on(table.tenantId, table.status),
  // Index for public slug lookups (globally unique, no RLS filter needed)
  slugIdx: index('dp_slug_idx').on(table.slug),
}));

/**
 * Stores a versioned, immutable snapshot of a screener's configuration.
 * A new record is created every time an admin saves changes.
 */
export const screenerVersions = appTable('screener_versions', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  drugProgramId: uuid('drug_program_id').notNull().references(() => drugPrograms.id, { onDelete: 'cascade' }),

  /**
   * The version number (1, 2, 3...) scoped to the drug program.
   * This is managed by the application logic (SELECT MAX(version) + 1).
   */
  version: integer('version').notNull(),
  
  /**
   * The complete screener definition as JSON, generated by the frontend builder.
   * Includes all questions, logic, branching, and EHR mappings.
   */
  screenerJson: jsonb('screener_json').notNull().default('{}'),
  
  // Admin-facing notes for this version (e.g., "v2.1 - Added EHR check")
  notes: varchar('notes', { length: 1024 }),
  
  ...auditSchema,
}, (table) => ({
  // Critical index for finding all versions for a program
  programVersionIdx: index('sv_program_version_idx').on(table.tenantId, table.drugProgramId, table.version),
}));

/**
 * Stores regulatory documentation for compliance and FDA submissions.
 * Includes SaMD, ACNU, V&V, risk management, and post-market surveillance docs.
 * RLS IS MANDATORY ON THIS TABLE.
 */
export const regulatoryDocuments = appTable('regulatory_documents', {
  id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  
  title: varchar('title', { length: 500 }).notNull(),
  category: regulatoryDocCategoryEnum('category').notNull(),
  description: varchar('description', { length: 2000 }),
  
  /**
   * Tags for filtering (e.g., ["FDA", "ISO 13485", "Partner-shareable"])
   * Stored as JSON array
   */
  tags: jsonb('tags').notNull().default('[]'),
  
  /**
   * Access level determines who can view this document:
   * - admin: Only admins can view
   * - internal: Internal users and admins
   * - external: External partners, internal users, and admins
   */
  accessLevel: accessLevelEnum('access_level').notNull().default('internal'),
  
  /**
   * URL to the document file (can be S3, Google Drive, etc.)
   */
  fileUrl: varchar('file_url', { length: 1000 }).notNull(),
  
  /**
   * Optional metadata for extensibility
   */
  metadata: jsonb('metadata'),
  
  ...auditSchema,
}, (table) => ({
  tenantCategoryIdx: index('rd_tenant_category_idx').on(table.tenantId, table.category),
  tenantAccessIdx: index('rd_tenant_access_idx').on(table.tenantId, table.accessLevel),
}));

// ------------------------------------------------------------------
// RELATIONS (Program-Scoped)
// ------------------------------------------------------------------

export const brandConfigsRelations = relations(brandConfigs, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [brandConfigs.tenantId],
    references: [tenants.id],
  }),
  drugPrograms: many(drugPrograms),
}));

export const drugProgramsRelations = relations(drugPrograms, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [drugPrograms.tenantId],
    references: [tenants.id],
  }),
  brandConfig: one(brandConfigs, {
    fields: [drugPrograms.brandConfigId],
    references: [brandConfigs.id],
  }),
  activeScreenerVersion: one(screenerVersions, {
    fields: [drugPrograms.activeScreenerVersionId],
    references: [screenerVersions.id],
    relationName: 'active_version',
  }),
  allScreenerVersions: many(screenerVersions, {
    relationName: 'all_versions',
  }),
  // Note: screeningSessions relation defined in consumer.ts to avoid circular dependency
}));

export const screenerVersionsRelations = relations(screenerVersions, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [screenerVersions.tenantId],
    references: [tenants.id],
  }),
  drugProgram: one(drugPrograms, {
    fields: [screenerVersions.drugProgramId],
    references: [drugPrograms.id],
    relationName: 'all_versions',
  }),
  // Note: screeningSessions relation defined in consumer.ts to avoid circular dependency
  
  // Relations for the createdBy/updatedBy fields from auditSchema
  creator: one(users, {
    fields: [screenerVersions.createdBy],
    references: [users.id],
    relationName: 'creator',
  }),
  updater: one(users, {
    fields: [screenerVersions.updatedBy],
    references: [users.id],
    relationName: 'updater',
  }),
}));

export const regulatoryDocumentsRelations = relations(regulatoryDocuments, ({ one }) => ({
  tenant: one(tenants, {
    fields: [regulatoryDocuments.tenantId],
    references: [tenants.id],
  }),
  creator: one(users, {
    fields: [regulatoryDocuments.createdBy],
    references: [users.id],
    relationName: 'doc_creator',
  }),
  updater: one(users, {
    fields: [regulatoryDocuments.updatedBy],
    references: [users.id],
    relationName: 'doc_updater',
  }),
}));
